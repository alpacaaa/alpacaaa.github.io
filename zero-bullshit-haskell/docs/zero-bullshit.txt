-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple and mildly useful webserver library.
--   
--   This Haskell package provides a very simple webserver implementation
--   similar to <tt>express.js</tt> or <tt>sinatra</tt>.
--   
--   It comes as part of the <a>Zero Bullshit Haskell</a> project, where
--   you can learn Haskell with hands on exercises and bullshit free
--   explanations!
@package zero-bullshit
@version 0.1.0.0


-- | A very simple webserver library inspired by <tt>express.js</tt>,
--   <tt>sinatra</tt>.and the likes.
--   
--   Use this library to complete the <a>Zero Bullshit Haskell
--   exercises</a>.
--   
--   If you're unsure on how to proceed, read more on how to setup your
--   <a>Local dev environment</a> to complete the exercises.
module Zero.Server

-- | Start the server on port <tt>7879</tt>.
--   
--   As an example, this is a server that exposes <tt>/hello</tt> and
--   <tt>/ping</tt> routes.
--   
--   <pre>
--   helloHandler :: Handler
--   helloHandler
--     = simpleHandler GET "/hello" (\req -&gt; stringResponse "hello")
--   
--   pingHandler :: Handler
--   pingHandler
--     = simpleHandler GET "/ping" (\req -&gt; stringResponse "pong")
--   
--   main :: IO ()
--   main
--     = startServer [ helloHandler, pingHandler ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl localhost:7879/hello
--   hello
--   
--   &gt;&gt;&gt; curl localhost:7879/ping
--   pong
--   </pre>
--   
--   The server will listen on port <tt>7879</tt>. If you're following
--   along with the exercises, they expect to find a server running on that
--   port. In other words, you are good to go!
startServer :: [Handler] -> IO ()

-- | An <a>Handler</a> is something that can handle HTTP requests. You can
--   create handlers with these functions:
--   
--   <ul>
--   <li><a>simpleHandler</a></li>
--   <li><a>effectfulHandler</a></li>
--   <li><a>handlersWithState</a></li>
--   </ul>
data Handler

-- | HTTP Method.
--   
--   Only <a>GET</a> or <a>POST</a> for simplicity.
data Method
GET :: Method
POST :: Method

-- | Most basic HTTP handler.
--   
--   With a <a>simpleHandler</a> you can turn a <a>Request</a> into a
--   <a>Response</a>, but you're not allowed to use any side effects or
--   maintain any state across requests.
--   
--   <pre>
--   handleRequest :: Request -&gt; Response
--   handleRequest req
--     = stringResponse "hello"
--   
--   helloHandler :: Handler
--   helloHandler
--     = simpleHandler GET "/hello" handleRequest
--   </pre>
simpleHandler :: Method -> String -> (Request -> Response) -> Handler

-- | HTTP Request.
--   
--   Whenever you want to inspect the content of a <a>Request</a>, use
--   <a>requestBody</a>.
data Request

-- | Extract the request body as a <a>String</a>. This is the raw request
--   body, no parsing happens at this stage.
requestBody :: Request -> String

-- | Given a <a>String</a>, either succesfully parse it to a type
--   <tt>a</tt> or return an error (as a <a>String</a>).
--   
--   Read the documentation for <a>FromJSON</a> for a practical example.
decodeJson :: FromJSON a => String -> Either String a

-- | HTTP Response.
--   
--   Note you <b>cannot</b> create values of this type directly. You'll
--   need something like <a>stringResponse</a>, <a>jsonResponse</a> or
--   <a>failureResponse</a>.
--   
--   <pre>
--   isBobHandler :: Request -&gt; Response
--   isBobHandler req
--     = if requestBody req == "Bob"
--         then stringResponse "It's definitely Bob."
--         else failureResponse "WOAH, not Bob. Be careful."
--   
--   main :: IO ()
--   main
--     = startServer
--         [ simpleHandler POST "/is-bob" isBobHandler ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl -XPOST localhost:7879/is-bob -d "Bob"
--   It's definitely Bob.
--   </pre>
data Response

-- | Create a <a>Response</a> with some raw value (just a plain
--   <a>String</a>).
stringResponse :: String -> Response

-- | Create a <a>Response</a> with some JSON value. It helps to read this
--   signature as:
--   
--   <pre>
--   If you give me something that can be serialized to JSON,
--   I'll give you back a response with a JSON serialized body.
--   </pre>
--   
--   As an example, <tt>magicNumbers</tt> of type <tt>[Int]</tt> can be
--   serialized to JSON, because both the <tt>List</tt> type and the
--   <tt>Int</tt> type can be turned into JSON.
--   
--   <pre>
--   magicNumbers :: [Int]
--   magicNumbers = [1, 5, 92, 108]
--   
--   numbersHandler :: Request -&gt; Response
--   numbersHandler req
--     = jsonResponse magicNumbers
--   </pre>
jsonResponse :: ToJSON a => a -> Response

-- | Create a <a>Response</a> with an error and set the status code to
--   <tt>400</tt>.
failureResponse :: String -> Response

-- | An handler that allows side effects (note the <a>IO</a> in <tt>IO
--   Response</tt>). Unlike a <a>simpleHandler</a>, you can now have
--   <a>IO</a> operations.
--   
--   For example, you might want to query a database or make an HTTP
--   request to some webservice and use the result in the <a>Response</a>
--   body.
effectfulHandler :: Method -> String -> (Request -> IO Response) -> Handler

-- | A data type to describe stateful handlers.
--   
--   Note that <a>startServer</a> only accepts <a>Handler</a> values, so
--   you'll have to find a way to turn a <a>StatefulHandler</a> into an
--   <a>Handler</a> (read up on <a>handlersWithState</a> as it does exactly
--   that).
data StatefulHandler state

-- | A <a>StatefulHandler</a> allows you to keep some state around across
--   requests. For example, if you want to implement a counter, you could
--   keep the current tally as state, and increase it everytime a
--   <a>Request</a> comes in.
--   
--   The tricky bit is understanding this callback <tt>(state -&gt; Request
--   -&gt; (state, Response))</tt>.
--   
--   Compare it with the simpler <tt>Request -&gt; Response</tt>. The
--   difference is that you get the current state as a parameter, and you
--   no longer return <b>just</b> the <tt>Response</tt>, but an updated
--   version of the state as well.
statefulHandler :: Method -> String -> (state -> Request -> (state, Response)) -> StatefulHandler state

-- | Once you have some <a>StatefulHandler</a>s that share the same state
--   type (that's important!), you can create a proper <a>Handler</a> to be
--   used in your server definition.
--   
--   In fact, you cannot use <a>StatefulHandler</a> directly in
--   <a>startServer</a>, as it only accepts values of type <a>Handler</a>.
--   
--   What's the first parameter <tt>state</tt> you ask? Well, it's the
--   initial state! The server needs an initial value to pass along the
--   first <a>Request</a>, how else would it be able to come up with some
--   state (especially given that it knows nothing about what
--   <tt>state</tt> _is_, it could be anything! Yay, polymorphysm).
handlersWithState :: state -> [StatefulHandler state] -> Handler

-- | How do I send a JSON response?
--   
--   Your type needs a <a>ToJSON</a> instance, which you can derive
--   automatically. (That's why you need the <tt>Generic</tt> thing, but
--   feel free to ignore, it's not important)
--   
--   <pre>
--   import GHC.Generics (Generic)
--   import qualified Zero.Server as Server
--   
--   data Person
--     = Person { name :: String, age :: Int }
--   deriving (Generic, Server.ToJSON)
--   </pre>
--   
--   Then you want to use <a>jsonResponse</a> to produce a <a>Response</a>
--   that contains the JSON representation of your type. Note that
--   <b>encoding to JSON cannot fail</b>, while parsing from JSON could
--   potentially fail if the JSON input is malformed.
--   
--   <pre>
--   myHandler :: Request -&gt; Response
--   myHandler req
--     = jsonResponse p
--     where
--       p = Person "bob" 69
--   </pre>
type ToJSON a = (ToJSON a)

-- | How do I turn a JSON value into a value of type <tt>a</tt>?
--   
--   Your type needs a <a>FromJSON</a> instance, which you can derive
--   automatically.
--   
--   (That's why you need the <tt>Generic</tt> thing, but feel free to
--   ignore, it's not important)
--   
--   <pre>
--   import GHC.Generics (Generic)
--   import qualified Zero.Server as Server
--   
--   data Person
--     = Person { name :: String, age :: Int }
--   deriving (Generic, Server.FromJSON)
--   </pre>
--   
--   Then you want to use <a>decodeJson</a> to either get an error (when
--   the JSON is invalid) or a value of type <tt>Person</tt>.
--   
--   <pre>
--   myHandler :: Request -&gt; Response
--   myHandler req
--     = stringResponse result
--     where
--       body
--         = requestBody req
--       result
--         = case decodeJson body of
--             Left err -&gt; "Failed to decode request body as a Person. It must be something else"
--             Right p  -&gt; "Yay! We have a person named: " &lt;&gt; (name p)
--   </pre>
type FromJSON a = (FromJSON a)
instance GHC.Show.Show Zero.Server.Request
instance GHC.Classes.Eq Zero.Server.Request
instance GHC.Show.Show Zero.Server.Method
instance GHC.Classes.Eq Zero.Server.Method
