<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Zero.Server</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Zero.Server.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">zero-bullshit-0.1.0.0: A simple and mildly useful webserver library.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Zero.Server</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Server</a></li><li><a href="#g:2">Request</a></li><li><a href="#g:3">Response</a></li><li><a href="#g:4">Advanced stuff</a></li><li><a href="#g:5">JSON encoding/decoding</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A very simple webserver library inspired by Sinatra, Express.js and the likes.</p><p>Use this library to complete the
 <a href="https://github.com/alpacaaa/zero-bullshit-haskell#exercises">Zero Bullshit Haskell exercises</a>.</p><p>If you're unsure on how to proceed, read more on how to setup your
 <a href="https://github.com/alpacaaa/zero-bullshit-haskell#toc-solve-exercise">Local dev environment</a>
 to complete the exercises.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:startServer">startServer</a> :: [<a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><span class="keyword">data</span> <a href="#t:Handler">Handler</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Method">Method</a><ul class="subs"><li>= <a href="#v:GET">GET</a></li><li>| <a href="#v:POST">POST</a></li></ul></li><li class="src short"><a href="#v:simpleHandler">simpleHandler</a> :: <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; (<a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; <a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a>) -&gt; <a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Request">Request</a></li><li class="src short"><a href="#v:requestBody">requestBody</a> :: <a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:decodeJson">decodeJson</a> :: <a href="Zero-Server.html#t:FromJSON" title="Zero.Server">FromJSON</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> a</li><li class="src short"><span class="keyword">data</span> <a href="#t:Response">Response</a></li><li class="src short"><a href="#v:stringResponse">stringResponse</a> :: <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a></li><li class="src short"><a href="#v:jsonResponse">jsonResponse</a> :: <a href="Zero-Server.html#t:ToJSON" title="Zero.Server">ToJSON</a> a =&gt; a -&gt; <a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a></li><li class="src short"><a href="#v:failureResponse">failureResponse</a> :: <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a></li><li class="src short"><a href="#v:effectfulHandler">effectfulHandler</a> :: <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; (<a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a>) -&gt; <a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:StatefulHandler">StatefulHandler</a> state</li><li class="src short"><a href="#v:statefulHandler">statefulHandler</a> :: <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; (state -&gt; <a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; (state, <a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a>)) -&gt; <a href="Zero-Server.html#t:StatefulHandler" title="Zero.Server">StatefulHandler</a> state</li><li class="src short"><a href="#v:handlersWithState">handlersWithState</a> :: state -&gt; [<a href="Zero-Server.html#t:StatefulHandler" title="Zero.Server">StatefulHandler</a> state] -&gt; <a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a></li><li class="src short"><a href="#v:startServerOnPort">startServerOnPort</a> :: <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [<a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><span class="keyword">type</span> <a href="#t:ToJSON">ToJSON</a> a = <a href="https://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson-Types.html#t:ToJSON" title="Data.Aeson.Types">ToJSON</a> a</li><li class="src short"><span class="keyword">type</span> <a href="#t:FromJSON">FromJSON</a> a = <a href="https://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson-Types.html#t:FromJSON" title="Data.Aeson.Types">FromJSON</a> a</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Server</h1></a><div class="top"><p class="src"><a id="v:startServer" class="def">startServer</a> :: [<a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Zero.Server.html#startServer" class="link">Source</a> <a href="#v:startServer" class="selflink">#</a></p><div class="doc"><p>Start the server on port <code>7879</code>.</p><p>As an example, this is a server that listens to <code>/hello</code> and <code>/ping</code> requests.</p><pre>helloHandler :: Handler
helloHandler
  = simpleHandler GET &quot;/hello&quot; (\req -&gt; stringResponse &quot;hello&quot;)

pingHandler :: Handler
pingHandler
  = simpleHandler GET &quot;/ping&quot; (\req -&gt; stringResponse &quot;pong&quot;)

main :: IO ()
main
  = startServer [ helloHandler, pingHandler ]</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>curl localhost:7879/hello
</code></strong>hello
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>curl localhost:7879/ping
</code></strong>pong
</pre><p>The server will listen on port <code>7879</code>. If you're following along with the
   exercises, they expect to find a server running on that port. In other words,
   you are good to go!</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Handler" class="def">Handler</a> <a href="src/Zero.Server.html#Handler" class="link">Source</a> <a href="#t:Handler" class="selflink">#</a></p><div class="doc"><p>An <code><a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a></code> is something that can handle HTTP requests.
   You can create handlers with these functions:</p><ul><li><code><a href="Zero-Server.html#v:simpleHandler" title="Zero.Server">simpleHandler</a></code></li><li><code><a href="Zero-Server.html#v:effectfulHandler" title="Zero.Server">effectfulHandler</a></code></li><li><code><a href="Zero-Server.html#v:handlersWithState" title="Zero.Server">handlersWithState</a></code></li></ul></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Method" class="def">Method</a> <a href="src/Zero.Server.html#Method" class="link">Source</a> <a href="#t:Method" class="selflink">#</a></p><div class="doc"><p>HTTP Method.</p><p>Only <code><a href="Zero-Server.html#v:GET" title="Zero.Server">GET</a></code> or <code><a href="Zero-Server.html#v:POST" title="Zero.Server">POST</a></code> for simplicity.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:GET" class="def">GET</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:POST" class="def">POST</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><details id="i:Method" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Method:Eq:1"></span> <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a></span> <a href="src/Zero.Server.html#line-68" class="link">Source</a> <a href="#t:Method" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Method:Eq:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Zero-Server.html">Zero.Server</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a> -&gt; <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a> -&gt; <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Method:Show:2"></span> <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a></span> <a href="src/Zero.Server.html#line-68" class="link">Source</a> <a href="#t:Method" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Method:Show:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Zero-Server.html">Zero.Server</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:simpleHandler" class="def">simpleHandler</a> :: <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; (<a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; <a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a>) -&gt; <a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a> <a href="src/Zero.Server.html#simpleHandler" class="link">Source</a> <a href="#v:simpleHandler" class="selflink">#</a></p><div class="doc"><p>Most basic HTTP handler.</p><p>With a <code><a href="Zero-Server.html#v:simpleHandler" title="Zero.Server">simpleHandler</a></code> you can turn a <code><a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a></code> into a <code><a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a></code>,
   but you're not allowed to use any side effects or maintain any state
   across requests.</p><pre>handleRequest :: Request -&gt; Response
handleRequest req
  = stringResponse &quot;hello&quot;

helloHandler :: Handler
helloHandler
  = simpleHandler GET &quot;/hello&quot; handleRequest</pre></div></div><a href="#g:2" id="g:2"><h1>Request</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Request" class="def">Request</a> <a href="src/Zero.Server.html#Request" class="link">Source</a> <a href="#t:Request" class="selflink">#</a></p><div class="doc"><p>HTTP Request.</p><p>Whenever you want to inspect the content of a <code><a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a></code>, use <code><a href="Zero-Server.html#v:requestBody" title="Zero.Server">requestBody</a></code>.</p></div><div class="subs instances"><details id="i:Request" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Request:Eq:1"></span> <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> <a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a></span> <a href="src/Zero.Server.html#line-75" class="link">Source</a> <a href="#t:Request" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Request:Eq:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Zero-Server.html">Zero.Server</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; <a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; <a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Request:Show:2"></span> <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> <a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a></span> <a href="src/Zero.Server.html#line-75" class="link">Source</a> <a href="#t:Request" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Request:Show:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Zero-Server.html">Zero.Server</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:requestBody" class="def">requestBody</a> :: <a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Zero.Server.html#requestBody" class="link">Source</a> <a href="#v:requestBody" class="selflink">#</a></p><div class="doc"><p>Extract the request body as a <code><a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>.
 This is the raw request body, no parsing happens at this stage.</p></div></div><div class="top"><p class="src"><a id="v:decodeJson" class="def">decodeJson</a> :: <a href="Zero-Server.html#t:FromJSON" title="Zero.Server">FromJSON</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> a <a href="src/Zero.Server.html#decodeJson" class="link">Source</a> <a href="#v:decodeJson" class="selflink">#</a></p><div class="doc"><p>Given a <code><a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>, either succesfully parse it to a type <code>a</code>
 or return an error (as a <code><a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>).
 It's very important for the compiler to know what the <code>a</code> type is.
 If you're having problem with `Ambiguous occurrence...`, read TODO.</p></div></div><a href="#g:3" id="g:3"><h1>Response</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Response" class="def">Response</a> <a href="src/Zero.Server.html#Response" class="link">Source</a> <a href="#t:Response" class="selflink">#</a></p><div class="doc"><p>HTTP Response.</p><p>Note you <strong>cannot</strong> create values of this type directly.
 You'll need something like <code><a href="Zero-Server.html#v:stringResponse" title="Zero.Server">stringResponse</a></code>, <code><a href="Zero-Server.html#v:jsonResponse" title="Zero.Server">jsonResponse</a></code> or <code><a href="Zero-Server.html#v:failureResponse" title="Zero.Server">failureResponse</a></code>.</p><pre>isBobHandler :: Request -&gt; Response
isBobHandler req
  = if requestBody req == &quot;Bob&quot;
      then stringResponse &quot;It's definitely Bob.&quot;
      else failureResponse &quot;WOAH, not Bob. Be careful.&quot;

main :: IO ()
main
  = startServer
      [ simpleHandler POST &quot;/is-bob&quot; isBobHandler ]</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>curl -XPOST localhost:7879/is-bob -d &quot;Bob&quot;
</code></strong>It's definitely Bob.
</pre></div></div><div class="top"><p class="src"><a id="v:stringResponse" class="def">stringResponse</a> :: <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a> <a href="src/Zero.Server.html#stringResponse" class="link">Source</a> <a href="#v:stringResponse" class="selflink">#</a></p><div class="doc"><p>Create a <code><a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a></code> with some raw value (just a plain <code><a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>).</p></div></div><div class="top"><p class="src"><a id="v:jsonResponse" class="def">jsonResponse</a> :: <a href="Zero-Server.html#t:ToJSON" title="Zero.Server">ToJSON</a> a =&gt; a -&gt; <a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a> <a href="src/Zero.Server.html#jsonResponse" class="link">Source</a> <a href="#v:jsonResponse" class="selflink">#</a></p><div class="doc"><p>Create a <code><a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a></code> with some JSON value.
   It helps to read this signature as:</p><pre>If you give me something that can be serialized to JSON,
I'll give you back a response with a JSON serialized body.</pre><p>As an example, <code>magicNumbers</code> of type <code>[Int]</code> can be serialized
   to JSON, because both the <code>List</code> type and the <code>Int</code> type can be
   turned into JSON.</p><pre>magicNumbers :: [Int]
magicNumbers = [1, 5, 92, 108]

numbersHandler :: Request -&gt; Response
numbersHandler req
  = jsonResponse magicNumbers</pre></div></div><div class="top"><p class="src"><a id="v:failureResponse" class="def">failureResponse</a> :: <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a> <a href="src/Zero.Server.html#failureResponse" class="link">Source</a> <a href="#v:failureResponse" class="selflink">#</a></p><div class="doc"><p>Create a <code><a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a></code> with an error and set the status code to <code>400</code>.</p></div></div><a href="#g:4" id="g:4"><h1>Advanced stuff</h1></a><div class="top"><p class="src"><a id="v:effectfulHandler" class="def">effectfulHandler</a> :: <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; (<a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a>) -&gt; <a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a> <a href="src/Zero.Server.html#effectfulHandler" class="link">Source</a> <a href="#v:effectfulHandler" class="selflink">#</a></p><div class="doc"><p>An handler that allows side effects (note the <code><a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a></code> in <code>IO Response</code>).
 Unlike a <code><a href="Zero-Server.html#v:simpleHandler" title="Zero.Server">simpleHandler</a></code>, you can now have <code><a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a></code> operations.</p><p>For example, you might want to query a database or make an HTTP request
 to some webservice and use the result in the <code><a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a></code> body.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:StatefulHandler" class="def">StatefulHandler</a> state <a href="src/Zero.Server.html#StatefulHandler" class="link">Source</a> <a href="#t:StatefulHandler" class="selflink">#</a></p><div class="doc"><p>A data type to describe stateful handlers.</p><p>Note that <code><a href="Zero-Server.html#v:startServer" title="Zero.Server">startServer</a></code> only accepts <code><a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a></code> values, so you'll have to
   find a way to turn a <code><a href="Zero-Server.html#t:StatefulHandler" title="Zero.Server">StatefulHandler</a></code> into an <code><a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a></code> (read up on
   <code><a href="Zero-Server.html#v:handlersWithState" title="Zero.Server">handlersWithState</a></code> as it does exactly that).</p></div></div><div class="top"><p class="src"><a id="v:statefulHandler" class="def">statefulHandler</a> :: <a href="Zero-Server.html#t:Method" title="Zero.Server">Method</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; (state -&gt; <a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a> -&gt; (state, <a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a>)) -&gt; <a href="Zero-Server.html#t:StatefulHandler" title="Zero.Server">StatefulHandler</a> state <a href="src/Zero.Server.html#statefulHandler" class="link">Source</a> <a href="#v:statefulHandler" class="selflink">#</a></p><div class="doc"><p>A <code><a href="Zero-Server.html#t:StatefulHandler" title="Zero.Server">StatefulHandler</a></code> allows you to keep some state around across requests.
   For example, if you want to implement a counter, you could keep the current
   tally as state, and increase it everytime a <code><a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a></code> comes in.</p><p>The tricky bit is understanding this callback <code>(state -&gt; Request -&gt; (state, Response))</code>.</p><p>Compare it with the simpler <code>Request -&gt; Response</code>. The difference is that you get
   the current state as a parameter, and you no longer return <strong>just</strong> the <code>Response</code>,
   but an updated version of the state as well. For a more in depth explanation,
   read TODO.</p></div></div><div class="top"><p class="src"><a id="v:handlersWithState" class="def">handlersWithState</a> :: state -&gt; [<a href="Zero-Server.html#t:StatefulHandler" title="Zero.Server">StatefulHandler</a> state] -&gt; <a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a> <a href="src/Zero.Server.html#handlersWithState" class="link">Source</a> <a href="#v:handlersWithState" class="selflink">#</a></p><div class="doc"><p>Once you have some <code><a href="Zero-Server.html#t:StatefulHandler" title="Zero.Server">StatefulHandler</a></code>s that share the same state type 
   (that's important!),
   you can create a proper <code><a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a></code> to be used in your server definition.</p><p>In fact, you cannot use <code><a href="Zero-Server.html#t:StatefulHandler" title="Zero.Server">StatefulHandler</a></code> directly in <code><a href="Zero-Server.html#v:startServer" title="Zero.Server">startServer</a></code>, as it only
   accepts values of type <code><a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a></code>.</p><p>What's the first parameter <code>state</code> you ask? Well, it's the initial state!
   The server needs an initial value to pass along the first <code><a href="Zero-Server.html#t:Request" title="Zero.Server">Request</a></code>, how
   else would it be able to come up with some state (especially given that it
   knows nothing about what <code>state</code> _is_, it could be anything! Yay, polymorphysm).</p></div></div><div class="top"><p class="src"><a id="v:startServerOnPort" class="def">startServerOnPort</a> :: <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [<a href="Zero-Server.html#t:Handler" title="Zero.Server">Handler</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Zero.Server.html#startServerOnPort" class="link">Source</a> <a href="#v:startServerOnPort" class="selflink">#</a></p><div class="doc"><p>Exactly like <code><a href="Zero-Server.html#v:startServer" title="Zero.Server">startServer</a></code>, but allows you to specify a different port.</p></div></div><a href="#g:5" id="g:5"><h1>JSON encoding/decoding</h1></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:ToJSON" class="def">ToJSON</a> a = <a href="https://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson-Types.html#t:ToJSON" title="Data.Aeson.Types">ToJSON</a> a <a href="src/Zero.Server.html#ToJSON" class="link">Source</a> <a href="#t:ToJSON" class="selflink">#</a></p><div class="doc"><p>How do I send a JSON response?</p><p>Your type needs a <code><a href="Zero-Server.html#t:ToJSON" title="Zero.Server">ToJSON</a></code> instance, which you can derive automatically.
   (That's why you need the <code>Generic</code> thing, but feel free to ignore, it's not important)</p><pre>import GHC.Generics (Generic)
import qualified Zero.Server as Server

data Person
  = Person { name :: String, age :: Int }
deriving (Generic, Server.ToJSON)</pre><p>Then you want to use <code><a href="Zero-Server.html#v:jsonResponse" title="Zero.Server">jsonResponse</a></code> to produce a <code><a href="Zero-Server.html#t:Response" title="Zero.Server">Response</a></code> that contains the JSON
 representation of your type. Note that <strong>encoding to JSON cannot fail</strong>, while parsing
 from JSON could potentially fail if the JSON input is malformed.</p><pre>myHandler :: Request -&gt; Response
myHandler req
  = jsonResponse p
  where
    p = Person &quot;bob&quot; 69</pre></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:FromJSON" class="def">FromJSON</a> a = <a href="https://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson-Types.html#t:FromJSON" title="Data.Aeson.Types">FromJSON</a> a <a href="src/Zero.Server.html#FromJSON" class="link">Source</a> <a href="#t:FromJSON" class="selflink">#</a></p><div class="doc"><p>How do I turn a JSON value into a value of type <code>a</code>?</p><p>Your type needs a <code><a href="Zero-Server.html#t:FromJSON" title="Zero.Server">FromJSON</a></code> instance, which you can derive automatically.</p><p>(That's why you need the <code>Generic</code> thing, but feel free to ignore, it's not important)</p><pre>import GHC.Generics (Generic)
import qualified Zero.Server as Server

data Person
  = Person { name :: String, age :: Int }
deriving (Generic, Server.FromJSON)</pre><p>Then you want to use <code><a href="Zero-Server.html#v:decodeJson" title="Zero.Server">decodeJson</a></code> to either get an error (when the JSON is invalid)
 or a value of type <code>Person</code></p><pre>myHandler :: Request -&gt; Response
myHandler req
  = stringResponse result
  where
    body
      = requestBody req
    result
      = case decodeJson body of
          Left err -&gt; &quot;Failed to decode request body as a Person. It must be something else&quot;
          Right p  -&gt; &quot;Yay! We have a person named: &quot; &lt;&gt; (name p)</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.20.0</p></div></body></html>